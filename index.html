<doctype html>
    <!-- Copyright 2020, Cem Yuksel, University of Utah -->
    <html>
    <head>
    <title>CS 4600 - Project Interactive Graphics</title>
    <script type="text/javascript" id="includedscript" src="project.js"></script>
    <script type="text/javascript" src="obj.js"></script>
    <script type="text/javascript">
    ///////////////////////////////////////////////////////////////////////////////////
    // Below is the code for the object that draws lines.
    ///////////////////////////////////////////////////////////////////////////////////
    class BoxDrawer {
        constructor()
        {
            // Compile the shader program
            this.prog = InitShaderProgram( boxVS, boxFS );
            
            // Get the ids of the uniform variables in the shaders
            this.mvp = gl.getUniformLocation( this.prog, 'mvp' );
            
            // Get the ids of the vertex attributes in the shaders
            this.vertPos = gl.getAttribLocation( this.prog, 'pos' );
            
            // Create the buffer objects
            
            this.vertbuffer = gl.createBuffer();
            var pos = [
                -1, -1, -1,
                -1, -1,  1,
                -1,  1, -1,
                -1,  1,  1,
                 1, -1, -1,
                 1, -1,  1,
                 1,  1, -1,
                 1,  1,  1 ];
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertbuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
    
            this.linebuffer = gl.createBuffer();
            var line = [
                0,1,   1,3,   3,2,   2,0,
                4,5,   5,7,   7,6,   6,4,
                0,4,   1,5,   3,7,   2,6 ];
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.linebuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(line), gl.STATIC_DRAW);
        }
        draw( trans )
        {
            // Draw the line segments
            gl.useProgram( this.prog );
            gl.uniformMatrix4fv( this.mvp, false, trans );
            gl.bindBuffer( gl.ARRAY_BUFFER, this.vertbuffer );
            gl.vertexAttribPointer( this.vertPos, 3, gl.FLOAT, false, 0, 0 );
            gl.enableVertexAttribArray( this.vertPos );
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.linebuffer );
            gl.drawElements( gl.LINES, 24, gl.UNSIGNED_BYTE, 0 );
        }
    }
    // Vertex shader source code
    var boxVS = `
        attribute vec3 pos;
        uniform mat4 mvp;
        void main()
        {
            gl_Position = mvp * vec4(pos,1);
        }
    `;
    // Fragment shader source code
    var boxFS = `
        precision mediump float;
        void main()
        {
            gl_FragColor = vec4(1,1,1,1);
        }
    `;
    ///////////////////////////////////////////////////////////////////////////////////
    </script>
    
    <script type="text/javascript">
    ///////////////////////////////////////////////////////////////////////////////////
    // Below is the code for the object that draws the selected vertex.
    ///////////////////////////////////////////////////////////////////////////////////
    class PointDrawer {
        constructor()
        {
            // Compile the shader program
            this.prog = InitShaderProgram( pointVS, pointFS );
            
            // Get the ids of the uniform variables in the shaders
            this.mvp = gl.getUniformLocation( this.prog, 'mvp' );
    
            // Get the ids of the vertex attributes in the shaders
            this.vertPos = gl.getAttribLocation( this.prog, 'pos' );
            
            // Create the buffer objects
            this.vertbuffer = gl.createBuffer();
        }
        setPoint(p)
        {
            if ( this.selVertex == p ) return false;
            this.selVertex = p;
            this.updatePoint();
            return true;
        }
        updatePoint()
        {
            if ( this.selVertex !== undefined ) {
                var pos = [ this.selVertex.x, this.selVertex.y, this.selVertex.z ];
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertbuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
            }
        }
        draw( trans )
        {
            if ( this.selVertex ) {
                gl.useProgram( this.prog );
                gl.uniformMatrix4fv( this.mvp, false, trans );
                gl.bindBuffer( gl.ARRAY_BUFFER, this.vertbuffer );
                gl.vertexAttribPointer( this.vertPos, 3, gl.FLOAT, false, 0, 0 );
                gl.enableVertexAttribArray( this.vertPos );
                gl.disable(gl.DEPTH_TEST);
                gl.drawArrays( gl.POINTS, 0, 1 );
                gl.enable(gl.DEPTH_TEST);
            }
        }
    }
    // Vertex shader source code
    var pointVS = `
        attribute vec3 pos;
        uniform mat4 mvp;
        void main()
        {
            gl_Position = mvp * vec4(pos,1);
            gl_PointSize = 10.0;
        }
    `;
    // Fragment shader source code
    var pointFS = `
        precision mediump float;
        void main()
        {
            gl_FragColor = vec4(1,0,0,1);
        }
    `;
    ///////////////////////////////////////////////////////////////////////////////////
    </script>

    <script type="text/javascript">
        ////////////////////////////////////
        //WaterDrawer and Sphere rendering ----> Switching to sphere instead of points, better develope
        ///////////////////////////////////
        class Grid3D {
            constructor(cellSize) {
                this.cellSize = cellSize;
                this.cells = new Map();
            }

            _hash(position) {
                const x = Math.floor(position[0] / this.cellSize);
                const y = Math.floor(position[1] / this.cellSize);
                const z = Math.floor(position[2] / this.cellSize);
                return `${x},${y},${z}`;
            }

            add(particle) {
                const hash = this._hash(particle.position);
                if (!this.cells.has(hash)) {
                    this.cells.set(hash, []);
                }
                this.cells.get(hash).push(particle);
            }

            clear() {
                this.cells.clear();
            }

            getNearby(particle) {
                const nearby = [];
                const [x, y, z] = [
                    Math.floor(particle.position[0] / this.cellSize),
                    Math.floor(particle.position[1] / this.cellSize),
                    Math.floor(particle.position[2] / this.cellSize)
                ];
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        for (let dz = -1; dz <= 1; dz++) {
                            const hash = `${x + dx},${y + dy},${z + dz}`;
                            if (this.cells.has(hash)) {
                                nearby.push(...this.cells.get(hash));
                            }
                        }
                    }
                }
                return nearby;
            }
        }

        class Particle {
            constructor(x, y, z) {
                this.position = [x, y, z];
                this.velocity = [0, 0, 0];
                this.force = [0, 0, 0];
                this.density = 0;
                this.pressure = 0;
                this.predictedPosition = [x, y, z];  // Posizione predetta
                this.lambda = 0;  // Coefficiente di correzione della posizione
                this.neighbors = [];  // Lista dei vicini
            }
        }


    class WaterDrawer {
        constructor() {
            this.prog = InitShaderProgram(waterVS, waterFS);
            this.mvp = gl.getUniformLocation(this.prog, 'mvp');
           
            this.model = gl.getUniformLocation(this.prog, 'model');
            this.lightPos = gl.getUniformLocation(this.prog, 'lightPos');
            this.viewPos = gl.getUniformLocation(this.prog, 'viewPos');
            this.lightColor = gl.getUniformLocation(this.prog, 'lightColor');
            this.objectColor = gl.getUniformLocation(this.prog, 'objectColor');
           
            this.vertPos = gl.getAttribLocation(this.prog, 'pos');
            this.particles = []; // Array per memorizzare le particelle ---- Inoltre tiene conto anche delle posizioni x y z 

            this.textureUniform = gl.getUniformLocation(this.prog, 'u_texture');
            this.texCoordAttr = gl.getAttribLocation(this.prog, 'a_texCoord');
            
            this.refractiveIndexLocation = gl.getUniformLocation(this.prog, 'refractiveIndex');


            this.createSphereGeometry(10, 10);  // Numero ridotto di latitudini e longitudini
            this.isRunning = false;
            this.innerCubeBounds = {min: {x: -0.5, y: -0.5, z: -0.5}, max: {x: 0.5, y: 0.5, z: 0.5}};  // Limiti del cubo interno
            this.massSpring;
            this.GRAVITY = [0, -9.81, 0] //I modify those constant in the other part of code (variable value) 
            this.MASS = 0.2;
            this.TIME_STEP = 0.035; 
            this.texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            this.image;

            const image = new Image();
            let imageSRC = "Sphere.png"; //Reminder for me, change this path to change image
            image.src = imageSRC; 
            image.onload = () => {
                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.bindTexture(gl.TEXTURE_2D, null);
            };
        }

        addPoint(p) {
            var part = new Particle(p.x, p.y, p.z);
            this.particles.push(part);
         //   this.updateParticles();
        }

        clearParticles() {
            this.particles = [];
          //  this.updateParticles();
        }

        setMassSpring(massSpring) {
            this.massSpring = massSpring;
        }

        //I define my mesh sphere
        createSphereGeometry(latBands, longBands) {
            this.vertexData = [];
            this.indexData = [];
            this.texCoordData = [];

            for (let lat = 0; lat <= latBands; lat++) {
                const theta = lat * Math.PI / latBands;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);

                for (let long = 0; long <= longBands; long++) {
                    const phi = long * 2 * Math.PI / longBands;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);

                    const xPos = cosPhi * sinTheta;
                    const yPos = cosTheta;
                    const zPos = sinPhi * sinTheta;

                    this.vertexData.push(xPos, yPos, zPos);
                    this.texCoordData.push(long / longBands, lat / latBands);
                }
            }

            for (let lat = 0; lat < latBands; lat++) {
                for (let long = 0; long < longBands; long++) {
                    const first = (lat * (longBands + 1)) + long;
                    const second = first + longBands + 1;

                    this.indexData.push(first, second, first + 1);
                    this.indexData.push(second, second + 1, first + 1);
                }
            }

            this.sphereBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.sphereBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertexData), gl.STATIC_DRAW);

            this.texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.texCoordData), gl.STATIC_DRAW);



            this.indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.indexData), gl.STATIC_DRAW);
        }

        draw(trans, viewMatrix, lightPosition) {
            if (this.particles.length > 0) {
                gl.useProgram(this.prog);
                gl.uniformMatrix4fv(this.mvp, false, trans);

                let modelMatrix = MatrixIdentity();
                gl.uniformMatrix4fv(this.model, false, modelMatrix);

                gl.uniform3fv(this.lightPos, lightPosition);
                gl.uniform3fv(this.viewPos, [0, 0, 5]); // Supponendo che la camera sia a z = 5
                gl.uniform3fv(this.lightColor, [1, 1, 1]); // Luce bianca
                gl.uniform3fv(this.objectColor, [0.6, 0.7, 1.0]); // Colore della particella

                gl.bindTexture(gl.TEXTURE_2D, this.texture);
                gl.uniform1i(this.textureUniform, 0); // Associa l'unità texture 0

                gl.uniform1f(this.refractiveIndexLocation, 1.33);  // 1.33 for water



                gl.bindBuffer(gl.ARRAY_BUFFER, this.sphereBuffer);
                gl.vertexAttribPointer(this.vertPos, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.vertPos);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordBuffer);
                gl.vertexAttribPointer(this.texCoordAttr, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.texCoordAttr);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                const scaleFactor = 0.03;  // Ridurre il fattore di scala per sfere più piccole

                for (let i = 0; i < this.particles.length; i++) {
                    const p = this.particles[i];
                    const modelTrans = MatrixTranslate(p.position[0], p.position[1], p.position[2]); //Here I take the Particles(x,y,z), so here I'm using the object Particle
                    const modelScale = MatrixScale(scaleFactor, scaleFactor, scaleFactor);
                    const modelViewProjection = MatrixMult(trans, MatrixMult(modelTrans, modelScale));

                    gl.uniformMatrix4fv(this.mvp, false, modelViewProjection);
             //       gl.uniformMatrix4fv(this.model, false,modelViewProjection); //TODO: fare il check
                    gl.drawElements(gl.TRIANGLES, this.indexData.length, gl.UNSIGNED_SHORT, 0);
                }
            }
        }

        // Metodo per calcolare la densità e la pressione
        computeDensityPressure() {
            for (let i = 0; i < this.particles.length; i++) {
                let pi = this.particles[i];
                pi.density = 0;
                for (let j = 0; j < this.particles.length; j++) {
                    let pj = this.particles[j];
                    let r2 = this.squaredDistance(pi.position, pj.position);
                    if (r2 < H * H) {
                        pi.density += this.MASS * this.poly6Kernel(r2);
                      //  console.log("RAGGIO" + r2);
                        //console.log("DENSITA: " + pi.density);
                    }
                }
                //console.log("DENSITA:" + pi.density);
                pi.pressure = GAS_CONST * (pi.density - REST_DENSITY);
               // console.log("PRESSIONE: " + pi.pressure);
                //console.log("MASS" + this.MASS)
            }
        }

        // Metodo per calcolare le forze
        computeForces() {
            for (let i = 0; i < this.particles.length; i++) {
                let pi = this.particles[i];
                pi.force = [0, 0, 0];
                for (let j = 0; j < this.particles.length; j++) {
                    if (i !== j) {
                        let pj = this.particles[j];
                        //console.log("P1" + pi.position[0] + "P2" + pj.position[0]);
                        let r2 = this.squaredDistance(pi.position, pj.position);
                        //console.log("PARTICLE DISTANCES :" + r2); 
                        if (r2 < H * H) {
                            let r = Math.sqrt(r2);

                            // Forza di pressione
                            let pressureForce = this.pressureKernelGradient(pi, pj, r);
                            pi.force[0] -= pressureForce[0] * 0.000003;
                            pi.force[1] -= pressureForce[1] * 0.000001;
                            pi.force[2] -= pressureForce[2] * 0.000003;

                            // Forza di viscosità
                            let viscosityForce = this.viscosityKernelLaplacian(pi, pj, r);
                            pi.force[0] += viscosityForce[0];
                            pi.force[1] += viscosityForce[1];
                            pi.force[2] += viscosityForce[2];

                             // Forza di repulsione
                            const repulsionStrength = 100.0; // Puoi regolare questa costante per cambiare la forza di repulsione
                            if (r < H * 0.9) {  // Applica la repulsione solo se le particelle sono molto vicine
                                let repulsionForce = (H - r) * repulsionStrength / r;
                               // console.log("CIAO A TUTTI SONO DENTRO");
                                pi.force[0] += repulsionForce * (pi.position[0] - pj.position[0]);
                                pi.force[1] += repulsionForce * (pi.position[1] - pj.position[1]);
                                pi.force[2] += repulsionForce * (pi.position[2] - pj.position[2]);
                                //console.log("F1: " +pi.force[0]  + " F2: " + pi.force[1]  + " F3: " + pi.force[2]);
                            }
                        }
                    }
                }
                // Aggiungere la forza di gravità
                pi.force[1] += pi.density * this.GRAVITY[1];
            }
        }


        // Metodo per aggiornare le posizioni delle particelle
        integrate() {
            for (let i = 0; i < this.particles.length; i++) {
                let pi = this.particles[i];
                //console.log("FORCE:" + pi.force + "velocity:" + pi.velocity + "pressure:" + pi.pressure + "density:" + pi.density);
                pi.velocity[0] += (pi.force[0] / pi.density) * this.TIME_STEP;
                pi.velocity[1] += (pi.force[1] / pi.density) * this.TIME_STEP;
                pi.velocity[2] += (pi.force[2] / pi.density) * this.TIME_STEP;

                pi.position[0] += pi.velocity[0] * this.TIME_STEP;
                pi.position[1] += pi.velocity[1] * this.TIME_STEP;
                pi.position[2] += pi.velocity[2] * this.TIME_STEP;

                this.handleCollision(pi);
            }
            this.handleParticleCollisions();
        }

        handleCollision(particle) {
            // Bordi del contenitore
            const minBound = -1.0;
            const maxBound = 1.0;

            for (let i = 0; i < 3; i++) {
                if (particle.position[i] < minBound) {
                    particle.position[i] = minBound; // Impedisce di andare oltre il bordo
                    particle.velocity[i] = -particle.velocity[i] * 0.9; // Inverte la velocità per simulare il rimbalzo
                } else if (particle.position[i] > maxBound) {
                    particle.position[i] = maxBound;
                    particle.velocity[i] = -particle.velocity[i] * 0.9 ;
                }
            }
        }

        handleParticleCollisions() {
            const grid = new Grid3D(0.06); // Due volte il raggio delle particelle
            const minDist = 2 * 0.03; 
            for (let i = 0; i < this.particles.length; i++) {
                grid.add(this.particles[i]);
            }

            for (let i = 0; i < this.particles.length; i++) {
                let pi = this.particles[i];
                let nearbyParticles = grid.getNearby(pi);

                for (let j = 0; j < nearbyParticles.length; j++) {
                    let pj = nearbyParticles[j];
                    if (pi === pj) continue; // Evita di confrontare la particella con sé stessa

                    let r2 = this.squaredDistance(pi.position, pj.position);
                    let r = Math.sqrt(r2);

                    if (r < minDist) {
                        let overlap = minDist - r;
                        let direction = [
                            (pi.position[0] - pj.position[0]) / r,
                            (pi.position[1] - pj.position[1]) / r,
                            (pi.position[2] - pj.position[2]) / r
                        ];

                        let separationForce = overlap * 0.1;

                        pi.position[0] += direction[0] * separationForce;
                        pi.position[1] += direction[1] * separationForce;
                        pi.position[2] += direction[2] * separationForce;

                        pj.position[0] -= direction[0] * separationForce;
                        pj.position[1] -= direction[1] * separationForce;
                        pj.position[2] -= direction[2] * separationForce;
                    }
                }
            }
        }

        printDebbuggingCubeVertices(v0, v1, v2){ //Uso questa funzione per debuggarmi handleCollisionWithCube 
             console.log("INDEX: " + i + "\n");
                console.log("V0 --> " + "POSIZIONE X --> " + v0.x +"\n"
                            +"POSIZIONE Y --> " + v0.y +"\n"
                            +"POSIZIONE Z --> " + v0.z
                );
                
                console.log("V1 --> " + "POSIZIONE X --> " + v1.x +"\n"
                            +"POSIZIONE Y --> " + v1.y +"\n"
                            +"POSIZIONE Z --> " + v1.z
                );

                console.log("V2 -- > " + "POSIZIONE X --> " + v2.x +"\n"
                            +"POSIZIONE Y --> " + v2.y +"\n"
                            +"POSIZIONE Z --> " + v2.z
                );
        }

        handleCollisionWithCube(particle, cubeVertices) {
            const minBound = [-1, -1, -1];
            const maxBound = [1, 1, 1];

            //BOUNDARY
            if (particle.position[0] < minBound[0] || particle.position[0] > maxBound[0] ||
                particle.position[1] < minBound[1] || particle.position[1] > maxBound[1] ||
                particle.position[2] < minBound[2] || particle.position[2] > maxBound[2]) {
                return;
            }

            const faceIndices = [
                [0, 1, 2], [0, 2, 3], // Front face
                [4, 5, 6], [4, 6, 7], // Back face
                [0, 1, 5], [0, 5, 4], // Bottom face
                [2, 3, 7], [2, 7, 6], // Top face
                [0, 3, 7], [0, 7, 4], // Left face
                [1, 2, 6], [1, 6, 5]  // Right face
            ];

            for (let i = 0; i < faceIndices.length; i++) {
                const v0 = cubeVertices[faceIndices[i][0]];
                const v1 = cubeVertices[faceIndices[i][1]];
                const v2 = cubeVertices[faceIndices[i][2]];

                const edge1 = [v1.x - v0.x, v1.y - v0.y, v1.z - v0.z];
                const edge2 = [v2.x - v0.x, v2.y - v0.y, v2.z - v0.z];
                const faceNormal = normalize(crossProduct(edge1, edge2));

                const particleToVertex = [
                    particle.position[0] - v0.x,
                    particle.position[1] - v0.y,
                    particle.position[2] - v0.z,
                ];

                const distance = dotProduct(faceNormal, particleToVertex);

                if (distance < 0) {
                    // Check if particle is within the triangle
                    if (isPointInTriangle(particle.position, v0, v1, v2)) {
                        const velocityDotNormal = dotProduct(faceNormal, particle.velocity);
                        const restitution = 0.1;  
                        for (let j = 0; j < 3; j++) {
                            particle.velocity[j] -= 2 * velocityDotNormal * faceNormal[j] * restitution;
                        }

                        const moveOutFactor = 0.01;
                        for (let j = 0; j < 3; j++) {
                            particle.position[j] += distance * faceNormal[j] * moveOutFactor;
                        }
                    }
                }
            }
        }

        
        predictPositions() {
        for (let i = 0; i < this.particles.length; i++) {
            let pi = this.particles[i];
            pi.velocity[0] += (pi.force[0] / pi.density) * this.TIME_STEP;
            pi.velocity[1] += (pi.force[1] / pi.density) * this.TIME_STEP;
            pi.velocity[2] += (pi.force[2] / pi.density) * this.TIME_STEP;
           // console.log("VELOCITA X: " + pi.velocity[0] + "\n" + "VELOCITA Y: " + pi.velocity[1] + "\n" + "VELOCITA Z: " + pi.velocity[2] + "\n");
           // console.log("FORZA Y:" + pi.force[1]);
            pi.predictedPosition[0] = pi.position[0] + pi.velocity[0] * this.TIME_STEP;
            pi.predictedPosition[1] = pi.position[1] + pi.velocity[1] * this.TIME_STEP;
            pi.predictedPosition[2] = pi.position[2] + pi.velocity[2] * this.TIME_STEP;
            //console.log("POS X: " + pi.predictedPosition[0] + "\n" + "POS Y: " + pi.predictedPosition[1] + "\n" + "POS Z: " + pi.predictedPosition[2] + "\n");

        }
    }

    // Trovare i vicini per ogni particella
    findNeighbors() {
        const radiusSquared = H * H;
        for (let i = 0; i < this.particles.length; i++) {
            let pi = this.particles[i];
            pi.neighbors = [];
            for (let j = 0; j < this.particles.length; j++) {
                if (i !== j) {
                    let pj = this.particles[j];
                    let r2 = this.squaredDistance(pi.predictedPosition, pj.predictedPosition);
                    if (r2 < radiusSquared) {
                        pi.neighbors.push(pj);
                    }
                }
            }
        }
    }

    // Calcolare i lambda per ogni particella
    calculateLambdas() {
        const epsilon = 0.0001;
        for (let i = 0; i < this.particles.length; i++) {
            let pi = this.particles[i];
            let densityConstraint = 0;

            for (let j = 0; j < pi.neighbors.length; j++) {
                let pj = pi.neighbors[j];
                let r2 = this.squaredDistance(pi.predictedPosition, pj.predictedPosition);
                densityConstraint += this.poly6Kernel(r2);
            }
            densityConstraint = (densityConstraint / REST_DENSITY) - 1;

            let sumGradientSquared = 0;
            let gradientSum = [0, 0, 0];

            for (let j = 0; j < pi.neighbors.length; j++) {
                let pj = pi.neighbors[j];
                let r = Math.sqrt(this.squaredDistance(pi.predictedPosition, pj.predictedPosition));
                let gradW = this.spikyKernelGradient(pi.predictedPosition, pj.predictedPosition, r);

                sumGradientSquared += gradW[0] ** 2 + gradW[1] ** 2 + gradW[2] ** 2;
                gradientSum[0] += gradW[0];
                gradientSum[1] += gradW[1];
                gradientSum[2] += gradW[2];
            }

            sumGradientSquared += gradientSum[0] ** 2 + gradientSum[1] ** 2 + gradientSum[2] ** 2;
            pi.lambda = -densityConstraint / (sumGradientSquared + epsilon);
        }
    }

    // Correggere le posizioni delle particelle
    correctPositions() {
        for (let i = 0; i < this.particles.length; i++) {
            let pi = this.particles[i];
            let deltaP = [0, 0, 0];

            for (let j = 0; j < pi.neighbors.length; j++) {
                let pj = pi.neighbors[j];
                let r = Math.sqrt(this.squaredDistance(pi.predictedPosition, pj.predictedPosition));
                let gradW = this.spikyKernelGradient(pi.predictedPosition, pj.predictedPosition, r);

                deltaP[0] += (pi.lambda + pj.lambda) * gradW[0];
                deltaP[1] += (pi.lambda + pj.lambda) * gradW[1];
                deltaP[2] += (pi.lambda + pj.lambda) * gradW[2];
            }

            pi.predictedPosition[0] += deltaP[0];
            pi.predictedPosition[1] += deltaP[1];
            pi.predictedPosition[2] += deltaP[2];
        }
    }

    // Aggiornare la velocità e la posizione delle particelle
    updatePositionsAndVelocities() {
        for (let i = 0; i < this.particles.length; i++) {
            let pi = this.particles[i];
            pi.velocity[0] = (pi.predictedPosition[0] - pi.position[0]) / this.TIME_STEP;
            pi.velocity[1] = (pi.predictedPosition[1] - pi.position[1]) / this.TIME_STEP;
            pi.velocity[2] = (pi.predictedPosition[2] - pi.position[2]) / this.TIME_STEP;
            //console.log("POS X: " + pi.velocity[0] + "\n" + "POS Y: " + pi.velocity[1] + "\n" + "POS Z: " + pi.velocity[2] + "\n");

            pi.position[0] = pi.predictedPosition[0];
            pi.position[1] = pi.predictedPosition[1];
            pi.position[2] = pi.predictedPosition[2];
            //console.log("POS X: " + pi.predictedPosition[0] + "\n" + "POS Y: " + pi.predictedPosition[1] + "\n" + "POS Z: " + pi.predictedPosition[2] + "\n");


            this.handleCollision(pi);  // Gestire le collisioni con i bordi del contenitore
            this.handleParticleCollisions();  // Gestire le collisioni tra le particelle
        }
    }

    // Funzioni kernel
    spikyKernelGradient(p1, p2, r) {
        const h = H;
        const h2 = h * h;
        const rVec = [
            p1[0] - p2[0],
            p1[1] - p2[1],
            p1[2] - p2[2],
        ];
        const factor = -45 / (Math.PI * h2 * h2) * (h - r);
        return [
            factor * rVec[0] / r,
            factor * rVec[1] / r,
            factor * rVec[2] / r
        ];
    }

    // Metodo principale per eseguire la simulazione
    simulate() {

       /* if (!this.massSpring) {
            console.error("MassSpring or its positions are not defined!");
            return;
        }

        if (!this.massSpring.pos) {
            console.error("Keep out mate");
            return; 
        }*/

        this.computeDensityPressure();    //  Calcolo di densità e pressione
        this.computeForces();             //  Calcolo delle forze
        this.integrate();
        //troppo pesante come implementazione
        //this.predictPositions();          // Predizione delle posizioni
        //this.findNeighbors();             //  Ricerca dei vicini
        //this.calculateLambdas();          //  Calcolo dei lambda
        //this.correctPositions();          //  Correzione delle posizioni
        //this.updatePositionsAndVelocities(); //  Aggiornamento delle velocità e delle posizioni
        let cubeVertices;
        if (this.massSpring !== undefined) {
            cubeVertices = this.massSpring.pos;
            //console.log("CUBEVERTICES --> " + cubeVertices);
           // console.log("LENGHT OF VERTEX --> " + cubeVertices.length);
            //console.log("THIS.MASSPRING--> " + this.massSpring.pos[7])
            for (let i = 0; i < this.particles.length; i++) {
               // console.log("HI I M HERE" + cubeVertices[8]);
            //*********COMMENTARE QUI PER RIMUOVERE L'INTERAZIONE CON IL CUBO, POTREBBE AVERE PROBLEMI CAUSA PC*
                this.handleCollisionWithCube(this.particles[i], cubeVertices); //*******************************
            //**************************************************************************************************
            }
        }

    }


        // Funzione helper per calcolare la distanza al quadrato
        squaredDistance(a, b) {
            return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2;
        }

        // Kernel poly6
        poly6Kernel(r2) {
            let h2 = H * H;
            if (r2 >= 0 && r2 <= h2) {
                return (315 / (64 * Math.PI * Math.pow(H, 9))) * Math.pow(h2 - r2, 3);
            } else {
                return 0;  // Kernel should return 0 when distance exceeds smoothing radius
            }
        }


        // Kernel gradiente della pressione
        pressureKernelGradient(pi, pj, r) {
            let h2 = H * H;
            let rVector = [
                pi.position[0] - pj.position[0],
                pi.position[1] - pj.position[1],
                pi.position[2] - pj.position[2],
            ];
            let factor = -45 / (Math.PI * h2 ** 2) * (H - r);
            return [
                factor * rVector[0] * (pi.pressure + pj.pressure) / (2 * pj.density),
                factor * rVector[1] * (pi.pressure + pj.pressure) / (2 * pj.density),
                factor * rVector[2] * (pi.pressure + pj.pressure) / (2 * pj.density),
            ];
        }

        // Kernel laplaciano della viscosità
        viscosityKernelLaplacian(pi, pj, r) {
            let h2 = H * H;
            let factor = 45 / (Math.PI * h2 ** 2) * (H - r);
            return [
                VISCOSITY * (pj.velocity[0] - pi.velocity[0]) / pj.density * factor,
                VISCOSITY * (pj.velocity[1] - pi.velocity[1]) / pj.density * factor,
                VISCOSITY * (pj.velocity[2] - pi.velocity[2]) / pj.density * factor,
            ];
        }

    }

    var waterVS = `
        attribute vec3 pos;
        attribute vec2 a_texCoord;  // Attributo per le coordinate delle texture

        uniform mat4 mvp;
        uniform mat4 model; // Matrice di modello

        varying vec3 v_normal; // Normale per la luce
        varying vec2 v_texCoord;
        varying vec3 v_fragPos; // Posizione del frammento per il calcolo della luce
        void main()
        {
            v_normal = normalize((model * vec4(pos, 0.0)).xyz); 
            v_fragPos = (model * vec4(pos, 1.0)).xyz; 
            gl_Position = mvp * vec4(pos, 1.0);

            v_texCoord = a_texCoord;
        }
    `;

    // Fresnel effect and Snell's Law.
    var waterFS = `
        precision mediump float;

        uniform sampler2D u_texture;
        uniform vec3 lightPos;
        uniform vec3 viewPos;
        uniform vec3 lightColor;
        uniform vec3 objectColor;
        uniform float refractiveIndex; 

        varying vec3 v_normal;
        varying vec2 v_texCoord;
        varying vec3 v_fragPos;

        void main() {
            // Normalize the normal vector and calculate lighting directions
            vec3 normal = normalize(v_normal);
            vec3 lightDir = normalize(lightPos - v_fragPos);
            vec3 viewDir = normalize(viewPos - v_fragPos);

            // Reflection and refraction calculations
            vec3 reflectDir = reflect(-lightDir, normal);

            // Refraction using Snell's law
            float n1 = 1.0;  // Air refractive index
            float n2 = refractiveIndex; // Water refractive index (e.g., 1.33)
            float eta = n1 / n2;
            float cosI = dot(-lightDir, normal);
            float sinT2 = eta * eta * (1.0 - cosI * cosI);
            vec3 refractDir;
            if (sinT2 <= 1.0) {
                refractDir = refract(-lightDir, normal, eta);
            } else {
                // Total internal reflection fallback
                refractDir = reflect(-lightDir, normal);
            }

            // Fresnel effect to blend reflection and refraction based on view angle
            float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), 3.0);

            // Sample texture
            vec3 textureColor = texture2D(u_texture, v_texCoord).rgb;

            // Apply Fresnel effect to combine reflection and refraction
            vec3 reflectionColor = texture2D(u_texture, reflectDir.xy).rgb;  
            vec3 refractionColor = texture2D(u_texture, v_texCoord).rgb;     

            // Mix reflection and refraction using Fresnel factor
            vec3 finalColor = mix(refractionColor, reflectionColor, fresnel);

            // Output final color
            gl_FragColor = vec4(finalColor * objectColor * lightColor, 1.0);
        }
    `;


///////////////////////CONSTANT VALUE/////////////////////////////////////// --> Somo inspiegabilmente gia presenti
    const H = 0.03;               // Raggio di influenza (kernel support radius)
    const REST_DENSITY = 1000;   // Densità di riposo del fluido
    const GAS_CONST = 2000;      // Costante del gas per la pressione
    const VISCOSITY = 0.1;       // Viscosità del fluido

////////////////////////////////////////////////////////////////////////////

///////////////////////HELPER FUNCTION FOR ME //////////////////////////////
    function MatrixScale(sx, sy, sz) {
        return [
            sx, 0,  0,  0,
            0,  sy, 0,  0,
            0,  0,  sz, 0,
            0,  0,  0,  1
        ];
    }

    function MatrixTranslate(x, y, z) {
        return [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            x, y, z, 1
        ];
    }

    // Helper function to check if a point is inside a triangle
    function isPointInTriangle(point, v0, v1, v2) {
        const v0v1 = [v1.x - v0.x, v1.y - v0.y, v1.z - v0.z];
        const v0v2 = [v2.x - v0.x, v2.y - v0.y, v2.z - v0.z];
        const v0p = [point[0] - v0.x, point[1] - v0.y, point[2] - v0.z];

        const dot00 = dotProduct(v0v1, v0v1);
        const dot01 = dotProduct(v0v1, v0v2);
        const dot02 = dotProduct(v0v1, v0p);
        const dot11 = dotProduct(v0v2, v0v2);
        const dot12 = dotProduct(v0v2, v0p);

        const invDenom = 1 / (dot00 * dot11 - dot01 * dot01);
        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        return (u >= 0) && (v >= 0) && (u + v <= 1);
    }

    function MatrixMult(a, b) {
        var c = new Array(16).fill(0);
        for (var i = 0; i < 4; i++) {
            for (var j = 0; j < 4; j++) {
                for (var k = 0; k < 4; k++) {
                    c[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                }
            }
        }
        return c;
    }

    function MatrixIdentity() {
        return [
            1, 0, 0, 0,  // Prima colonna
            0, 1, 0, 0,  // Seconda colonna
            0, 0, 1, 0,  // Terza colonna
            0, 0, 0, 1   // Quarta colonna
        ];
    }

    function crossProduct(v1, v2) {
        return [
            v1[1] * v2[2] - v1[2] * v2[1],
            v1[2] * v2[0] - v1[0] * v2[2],
            v1[0] * v2[1] - v1[1] * v2[0],
        ];
    }

    // This is a utility function to calculate the dot product of two vectors
    function dotProduct(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }

    function normalize(v) {
        const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
        return [v[0] / length, v[1] / length, v[2] / length];
    }

//////////////////////////////////////////////////////////////////////
    </script>
    
    <script type="text/javascript">
    ///////////////////////////////////////////////////////////////////////////////////
    // Below is the core WebGL initialization code.
    ///////////////////////////////////////////////////////////////////////////////////
    var boxDrawer;
    var pointDrawer;
    var meshDrawer;
    var waterDrawer;
    var canvas, gl;
    var rotX=0, rotY=0, transY=0, transZ=3;
    var MV, MVP; // view matrices
    
    // Called once to initialize
    function InitWebGL()
    {
        // Initialize the WebGL canvas
        canvas = document.getElementById("canvas");
        canvas.oncontextmenu = function() {return false;};
        gl = canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
        if (!gl) {
            alert("Unable to initialize WebGL. Your browser or machine may not support it.");
            return;
        }
        
        // Initialize settings
        gl.clearColor(0,0,0,0);
        gl.enable(gl.DEPTH_TEST);
        
        // Initialize the programs and buffers for drawing
        boxDrawer   = new BoxDrawer();
        pointDrawer = new PointDrawer();
        meshDrawer  = new MeshDrawer();
        waterDrawer = new WaterDrawer();
       // massSpring =  new MassSpring();
       // waterDrawer.setMassSpring(massSpring);
        //console.log("WaterDrawer.massSpring: " + waterDrawer.massSpring);
       // console.log("MASS_SPRING:" + massSpring);
        
        //INIT PARTICLES
        const PARTICLES = 3500;  //TODO: Abbassato a 1000 perchè devo ottimizzares
        for (let i = 0; i < PARTICLES; i++) {
            let x = -1 + Math.random() * 2;  // x tra -1 e 1
            let y = -1.5 + Math.random();      // y tra -1 e 0
            let z = -1 + Math.random() * 2;  // z tra -1 e 1
            
            if (y >= -1 && y <= 1) { 
                waterDrawer.addPoint({x: x, y: y, z: z});
            }
        }

        
        // Set the viewport size
        UpdateCanvasSize();

    } 

    function startWaterSimulation() {
        if (waterDrawer.isRunning){
            waterDrawer.simulate();
            //waterDrawer.draw(MVP);
            //if (waterDrawer.massSpring != null)
                //console.log("PROVA: " + waterDrawer.massSpring.pos[0].unit());
            //    console.log("");
            //console.log("NODES: " + massSpring.nodes[0]);
            requestAnimationFrame(startWaterSimulation);
            DrawScene();
            
            //  console.log("PROVA: " + waterDrawer.massSpring);
        } 
    }
    
    // Called every time the window size is changed.
    function UpdateCanvasSize()
    {
        canvas.style.width  = "100%";
        canvas.style.height = "100%";
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.width  = pixelRatio * canvas.clientWidth;
        canvas.height = pixelRatio * canvas.clientHeight;
        const width  = (canvas.width  / pixelRatio);
        const height = (canvas.height / pixelRatio);
        canvas.style.width  = width  + 'px';
        canvas.style.height = height + 'px';
        gl.viewport( 0, 0, canvas.width, canvas.height );
        UpdateViewMatrices();
    }
    
    function ProjectionMatrix( c, z, fov_angle=60 )
    {
        var r = c.width / c.height;
        var n = (z - 1.74);
        const min_n = 0.001;
        if ( n < min_n ) n = min_n;
        var f = (z + 1.74);;
        var fov = 3.145 * fov_angle / 180;
        var s = 1 / Math.tan( fov/2 );
        return [
            s/r, 0, 0, 0,
            0, s, 0, 0,
            0, 0, (n+f)/(f-n), 1,
            0, 0, -2*n*f/(f-n), 0
        ];
    }
    
    function UpdateViewMatrices()
    {
        var perspectiveMatrix = ProjectionMatrix( canvas, transZ );
        MV  = GetModelViewMatrix( 0, transY, transZ, rotX, rotY );
        MVP = MatrixMult( perspectiveMatrix, MV );
    }
    
    // This is the main function that handled WebGL drawing
    function DrawScene()
    {
        // Clear the screen and the depth buffer.
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
        
        // Draw the curve and then the line segments that connect the control points.
        var nrmTrans = [ MV[0],MV[1],MV[2], MV[4],MV[5],MV[6], MV[8],MV[9],MV[10] ];
        meshDrawer.draw( MVP, MV, nrmTrans );
        if ( showBox.checked ) {
            boxDrawer.draw( MVP );
        }
        pointDrawer.draw( MVP );
        
        let lightPosition = [1.0, 2.0, 3.0];
        waterDrawer.draw(MVP, MV, lightPosition);
    }
    
    // This is a helper function for compiling the given vertex and fragment shader source code into a program.
    function InitShaderProgram( vsSource, fsSource, wgl=gl )
    {
        const vs = CompileShader( wgl.VERTEX_SHADER,   vsSource, wgl );
        const fs = CompileShader( wgl.FRAGMENT_SHADER, fsSource, wgl );
    
        const prog = wgl.createProgram();
        wgl.attachShader(prog, vs);
        wgl.attachShader(prog, fs);
        wgl.linkProgram(prog);
    
        if (!wgl.getProgramParameter(prog, wgl.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + wgl.getProgramInfoLog(prog));
            return null;
        }
        return prog;
    }
    
    // This is a helper function for compiling a shader, called by InitShaderProgram().
    function CompileShader( type, source, wgl=gl )
    {
        const shader = wgl.createShader(type);
        wgl.shaderSource(shader, source);
        wgl.compileShader(shader);
        if (!wgl.getShaderParameter( shader, wgl.COMPILE_STATUS) ) {
            alert('An error occurred compiling shader:\n' + wgl.getShaderInfoLog(shader));
            wgl.deleteShader(shader);
            return null;
        }
        return shader;
    }
    
    // Multiplies two matrices and returns the result A*B.
    // The arguments A and B are arrays, representing column-major matrices.
    function MatrixMult( A, B )
    {
        var C = Array(16);
        for ( var i=0, m=0; i<4; ++i ) {
            for ( var j=0; j<4; ++j, ++m ) {
                var v = 0;
                for ( var k=0; k<4; ++k ) {
                    v += A[j+4*k] * B[k+4*i];
                }
                C[m] = v;
            }
        }
        return C;
    }
    
    // Returns the inverse of the given 4x4 matrix
    function MatrixInverse( m )
    {
        var r = Array(16);
        
        var v_11_14__10_15 = m[11] * m[14] - m[10] * m[15];
        var v_10_15__11_14 = m[10] * m[15] - m[11] * m[14];
        var v__7_14___6_15 = m[ 7] * m[14] - m[ 6] * m[15];
        var v__6_11___7_10 = m[ 6] * m[11] - m[ 7] * m[10];
    
        var v__9_15__11_13 = m[ 9] * m[15] - m[11] * m[13];
        var v_11_13___9_15 = m[11] * m[13] - m[ 9] * m[15];
        var v__5_15___7_13 = m[ 5] * m[15] - m[ 7] * m[13];
        var v__7__9___5_11 = m[ 7] * m[ 9] - m[ 5] * m[11];
        
        var v_10_13___9_14 = m[10] * m[13] - m[ 9] * m[14];
        var v__9_14__10_13 = m[ 9] * m[14] - m[10] * m[13];
        var v__6_13___5_14 = m[ 6] * m[13] - m[ 5] * m[14];
        var v__5_10___6__9 = m[ 5] * m[10] - m[ 6] * m[ 9];
        
        var v_11_12___8_15 = m[11] * m[12] - m[ 8] * m[15];
        var v__8_15__11_12 = m[ 8] * m[15] - m[11] * m[12];
        var v__7_12___4_15 = m[ 7] * m[12] - m[ 4] * m[15];
        var v__4_11___7__8 = m[ 4] * m[11] - m[ 7] * m[ 8];
        
        var v__8_14__10_12 = m[ 8] * m[14] - m[10] * m[12];
        var v_10_12___8_14 = m[10] * m[12] - m[ 8] * m[14];
        var v__4_14___6_12 = m[ 4] * m[14] - m[ 6] * m[12];
        var v__6__8___4_10 = m[ 6] * m[ 8] - m[ 4] * m[10];
        
        var v__9_12___8_13 = m[ 9] * m[12] - m[ 8] * m[13];
        var v__8_13___9_12 = m[ 8] * m[13] - m[ 9] * m[12];
        var v__5_12___4_13 = m[ 5] * m[12] - m[ 4] * m[13];
        var v__4__9___5__8 = m[ 4] * m[ 9] - m[ 5] * m[ 8];
    
        r[ 0] = m[5] * (-v_11_14__10_15) + m[6] * (-v__9_15__11_13) + m[7] * (-v_10_13___9_14);
        r[ 1] = m[1] * (-v_10_15__11_14) + m[2] * (-v_11_13___9_15) + m[3] * (-v__9_14__10_13);
        r[ 2] = m[1] * (-v__7_14___6_15) + m[2] * (-v__5_15___7_13) + m[3] * (-v__6_13___5_14);
        r[ 3] = m[1] * (-v__6_11___7_10) + m[2] * (-v__7__9___5_11) + m[3] * (-v__5_10___6__9);
        
        r[ 4] = m[4] * ( v_11_14__10_15) + m[6] * (-v_11_12___8_15) + m[7] * (-v__8_14__10_12);
        r[ 5] = m[0] * ( v_10_15__11_14) + m[2] * (-v__8_15__11_12) + m[3] * (-v_10_12___8_14);
        r[ 6] = m[0] * ( v__7_14___6_15) + m[2] * (-v__7_12___4_15) + m[3] * (-v__4_14___6_12);
        r[ 7] = m[0] * ( v__6_11___7_10) + m[2] * (-v__4_11___7__8) + m[3] * (-v__6__8___4_10);
        
        r[ 8] = m[4] * ( v__9_15__11_13) + m[5] * ( v_11_12___8_15) + m[7] * (-v__9_12___8_13);
        r[ 9] = m[0] * ( v_11_13___9_15) + m[1] * ( v__8_15__11_12) + m[3] * (-v__8_13___9_12);
        r[10] = m[0] * ( v__5_15___7_13) + m[1] * ( v__7_12___4_15) + m[3] * (-v__5_12___4_13);
        r[11] = m[0] * ( v__7__9___5_11) + m[1] * ( v__4_11___7__8) + m[3] * (-v__4__9___5__8);
    
        r[12] = m[4] * ( v_10_13___9_14) + m[5] * ( v__8_14__10_12) + m[6] * ( v__9_12___8_13);
        r[13] = m[0] * ( v__9_14__10_13) + m[1] * ( v_10_12___8_14) + m[2] * ( v__8_13___9_12);
        r[14] = m[0] * ( v__6_13___5_14) + m[1] * ( v__4_14___6_12) + m[2] * ( v__5_12___4_13);
        r[15] = m[0] * ( v__5_10___6__9) + m[1] * ( v__6__8___4_10) + m[2] * ( v__4__9___5__8);
    
        var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
        for ( var i=0; i<16; ++i ) r[i] /= det;
        
        return r;
    }
    
    ///////////////////////////////////////////////////////////////////////////////////
    </script>
    
    <script type="text/javascript">
    ///////////////////////////////////////////////////////////////////////////////////
    // Below is the light view control code
    ///////////////////////////////////////////////////////////////////////////////////
    
    var lightView;
    
    class LightView
    {
        constructor()
        {
            this.canvas = document.getElementById("lightcontrol");
            this.canvas.oncontextmenu = function() {return false;};
            this.gl = this.canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
            if (!this.gl) {
                alert("Unable to initialize WebGL. Your browser or machine may not support it.");
                return;
            }
            
            // Initialize settings
            this.gl.clearColor(0.33,0.33,0.33,0);
            this.gl.enable(gl.DEPTH_TEST);
            
            this.rotX = 0;
            this.rotY = 0;
            this.posZ = 5;
            
            this.resCircle = 32;
            this.resArrow = 16;
            this.buffer = this.gl.createBuffer();
            var data = [];
            for ( var i=0; i<=this.resCircle; ++i ) {
                var a = 2 * Math.PI * i / this.resCircle;
                var x = Math.cos(a);
                var y = Math.sin(a);
                data.push( x * .9 );
                data.push( y * .9 );
                data.push( 0 );
                data.push( x );
                data.push( y );
                data.push( 0 );
            }
            for ( var i=0; i<=this.resCircle; ++i ) {
                var a = 2 * Math.PI * i / this.resCircle;
                var x = Math.cos(a);
                var y = Math.sin(a);
                data.push( x );
                data.push( y );
                data.push( -.05 );
                data.push( x );
                data.push( y );
                data.push( 0.05 );
            }
            for ( var i=0; i<=this.resArrow; ++i ) {
                var a = 2 * Math.PI * i / this.resArrow;
                var x = Math.cos(a) * .07;
                var y = Math.sin(a) * .07;
                data.push( x );
                data.push( y );
                data.push( -1 );
                data.push( x );
                data.push( y );
                data.push( 0 );
            }
            data.push( 0 );
            data.push( 0 );
            data.push( -1.2 );
            for ( var i=0; i<=this.resArrow; ++i ) {
                var a = 2 * Math.PI * i / this.resArrow;
                var x = Math.cos(a) * .15;
                var y = Math.sin(a) * .15;
                data.push( x );
                data.push( y );
                data.push( -0.9 );
            }
            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
            this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
            
            // Set the viewport size
            this.canvas.style.width  = "";
            this.canvas.style.height = "";
            const pixelRatio = window.devicePixelRatio || 1;
            this.canvas.width  = pixelRatio * this.canvas.clientWidth;
            this.canvas.height = pixelRatio * this.canvas.clientHeight;
            const width  = (this.canvas.width  / pixelRatio);
            const height = (this.canvas.height / pixelRatio);
            this.canvas.style.width  = width  + 'px';
            this.canvas.style.height = height + 'px';
            this.gl.viewport( 0, 0, this.canvas.width, this.canvas.height );
            this.proj = ProjectionMatrix( this.canvas, this.posZ, 30 );
            
            // Compile the shader program
            this.prog = InitShaderProgram( lightViewVS, lightViewFS, this.gl );
            this.mvp = this.gl.getUniformLocation( this.prog, 'mvp' );
            this.clr1 = this.gl.getUniformLocation( this.prog, 'clr1' );
            this.clr2 = this.gl.getUniformLocation( this.prog, 'clr2' );
            this.vertPos = this.gl.getAttribLocation( this.prog, 'pos' );
            
            this.draw();
            this.updateLightDir();
            
            this.canvas.onmousedown = function() {
                var cx = event.clientX;
                var cy = event.clientY;
                lightView.canvas.onmousemove = function() {
                    lightView.rotY += (cx - event.clientX)/lightView.canvas.width*5;
                    lightView.rotX += (cy - event.clientY)/lightView.canvas.height*5;
                    cx = event.clientX;
                    cy = event.clientY;
                    lightView.draw();
                    lightView.updateLightDir();
                }
            }
            this.canvas.onmouseup = this.canvas.onmouseleave = function() {
                lightView.canvas.onmousemove = null;
            }
        }
        
        updateLightDir()
        {
            var cy = Math.cos( this.rotY );
            var sy = Math.sin( this.rotY );
            var cx = Math.cos( this.rotX );
            var sx = Math.sin( this.rotX );
            meshDrawer.setLightDir( -sy, cy*sx, -cy*cx );
            DrawScene();
        }
        
        draw()
        {
            // Clear the screen and the depth buffer.
            this.gl.clear( this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT );
            
            this.gl.bindBuffer( this.gl.ARRAY_BUFFER, this.buffer );
            this.gl.vertexAttribPointer( this.vertPos, 3, this.gl.FLOAT, false, 0, 0 );
            this.gl.enableVertexAttribArray( this.buffer );
    
            this.gl.useProgram( this.prog );
            var mvp = MatrixMult( this.proj, [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,this.posZ,1 ] );
            this.gl.uniformMatrix4fv( this.mvp, false, mvp );
            this.gl.uniform3f( this.clr1, 0.6,0.6,0.6 );
            this.gl.uniform3f( this.clr2, 0,0,0 );
            this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );
    
            var mv  = GetModelViewMatrix( 0, 0, this.posZ, this.rotX, this.rotY );
            var mvp = MatrixMult( this.proj, mv );
            this.gl.uniformMatrix4fv( this.mvp, false, mvp );
            this.gl.uniform3f( this.clr1, 1,1,1 );
            this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );
            this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*2+2, this.resCircle*2+2 );
            this.gl.uniform3f( this.clr1, 0,0,0 );
            this.gl.uniform3f( this.clr2, 1,1,1 );
            this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*4+4, this.resArrow*2+2 );
            this.gl.drawArrays( this.gl.TRIANGLE_FAN, this.resCircle*4+4 + this.resArrow*2+2, this.resArrow+2 );
        }
    }
    
    // Vertex shader source code
    const lightViewVS = `
        attribute vec3 pos;
        uniform mat4 mvp;
        void main()
        {
            gl_Position = mvp * vec4(pos,1);
        }
    `;
    // Fragment shader source code
    var lightViewFS = `
        precision mediump float;
        uniform vec3 clr1;
        uniform vec3 clr2;
        void main()
        {
            gl_FragColor = gl_FrontFacing ? vec4(clr1,1) : vec4(clr2,1);
        }
    `;
    ///////////////////////////////////////////////////////////////////////////////////
    </script>
    
    <script type="text/javascript">
    ///////////////////////////////////////////////////////////////////////////////////
    // Below is the mass-spring system code
    ///////////////////////////////////////////////////////////////////////////////////
    var massSpring;
    
    class Vec3 {
        constructor( x, y, z ) { this.init(x,y,z); }
        init( x, y, z ) { this.x=x; this.y=y; this.z=z; }
        copy ( ) { return new Vec3( this.x, this.y, this.z ); }
        set  (v) { this.x =v.x; this.y =v.y; this.z =v.z; }
        inc  (v) { this.x+=v.x; this.y+=v.y; this.z+=v.z; }
        dec  (v) { this.x-=v.x; this.y-=v.y; this.z-=v.z; }
        scale(f) { this.x*=f; this.y*=f; this.z*=f; }
        add  (v) { return new Vec3( this.x+v.x, this.y+v.y, this.z+v.z ); }
        sub  (v) { return new Vec3( this.x-v.x, this.y-v.y, this.z-v.z ); }
        dot  (v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
        cross(v) { return new Vec3( this.y*v.z-this.z*v.y, this.z*v.x-this.x*v.z, this.x*v.y-this.y*v.x ); }
        mul  (f) { return new Vec3( this.x*f, this.y*f, this.z*f ); }
        div  (f) { return new Vec3( this.x/f, this.y/f, this.z/f ); }
        len2 ( ) { return this.dot(this); }
        len  ( ) { return Math.sqrt(this.len2()); }
        unit ( ) { return this.div(this.len()); }
        normalize() {
            var l = this.len();
            this.x /= l;
            this.y /= l;
            this.z /= l;
        }
        trans(m) {
            return {
                x: m[0]*this.x + m[4]*this.y + m[ 8]*this.z + m[12],
                y: m[1]*this.x + m[5]*this.y + m[ 9]*this.z + m[13],
                z: m[2]*this.x + m[6]*this.y + m[10]*this.z + m[14],
                w: m[3]*this.x + m[7]*this.y + m[11]*this.z + m[15]
            };
        }
    }
    
    function ToVec3(a) { return new Vec3(a[0],a[1],a[2]); }
    
    class MassSpring {
    
        constructor()
        {
            this.gravity = new Vec3( 0, -2.0, 0 );
            this.mass = .1;
            this.stiffness = 1;
            this.damping = 1;
            this.restitution = .8;
            this.setMesh( document.getElementById('box.obj').text );
            this.nodes = []
        }

        applyForceToNode(nodeIndex, force) {
            this.nodes[nodeIndex].force.add(force);
        }

        setMesh( objdef )
        {
            this.mesh = new ObjMesh;
            this.mesh.parse( objdef );
            var box = this.mesh.getBoundingBox();
            var shift = [
                -(box.min[0]+box.max[0])/2,
                -(box.min[1]+box.max[1])/2,
                -(box.min[2]+box.max[2])/2
            ];
            var size = [
                (box.max[0]-box.min[0])/2,
                (box.max[1]-box.min[1])/2,
                (box.max[2]-box.min[2])/2
            ];
            var maxSize = Math.max( size[0], size[1], size[2] );
            var scale = 0.4/maxSize;
            this.mesh.shiftAndScale( shift, scale );
            this.mesh.computeNormals();
            this.reset();
            this.initSprings();
            DrawScene();
        }
        initSprings()
        {
            this.springs = [];
            for ( var i=0; i<this.pos.length; ++i ) {
                for ( var j=i+1; j<this.pos.length; ++j ) {
                    var r = this.pos[i].sub(this.pos[j]).len();
                    if ( r > .02 ) 
                    {
                        this.springs.push( { p0:i, p1:j, rest:r } );
                    }
                }
            }
        }
        reset()
        {
            this.pos = Array( this.mesh.vpos.length );
            for ( var i=0; i<this.pos.length; ++i ) this.pos[i] = ToVec3( this.mesh.vpos[i] );
            this.vel = Array( this.pos.length );
            for ( var i=0; i<this.vel.length; ++i ) this.vel[i] = new Vec3(0,0,0);
            this.nrm = Array( this.mesh.norm.length );
            for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i] = ToVec3( this.mesh.norm[i] );
            this.buffers = this.mesh.getVertexBuffers();
            meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );
           // waterDrawer.clearParticles();
            //GenerateParticles();
        }
    
        updateMesh()
        {
            function updateBuffer( buffer, faces, verts )
            {
                function addTriangleToBuffer( buffer, bi, vals, i, j, k )
                {
                    buffer[bi++] = vals[i].x;
                    buffer[bi++] = vals[i].y;
                    buffer[bi++] = vals[i].z;
                    buffer[bi++] = vals[j].x;
                    buffer[bi++] = vals[j].y;
                    buffer[bi++] = vals[j].z;
                    buffer[bi++] = vals[k].x;
                    buffer[bi++] = vals[k].y;
                    buffer[bi++] = vals[k].z;
                }
                for ( var i=0, bi=0; i<faces.length; ++i ) {
                    var f = faces[i];
                    if ( f.length < 3 ) continue;
                    addTriangleToBuffer( buffer, bi, verts, f[0], f[1], f[2] );
                    bi += 9;
                    for ( var j=3; j<f.length; ++j, bi+=9 ) {
                        addTriangleToBuffer( buffer, bi, verts, f[0], f[j-1], f[j] );
                    }
                }
            }
            
            // update the position buffer
            updateBuffer( this.buffers.positionBuffer, this.mesh.face, this.pos );
            
            // update normals
            for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].init(0,0,0);
            for ( var i=0; i<this.mesh.face.length; ++i ) {
                var f = this.mesh.face[i];
                var nf = this.mesh.nfac[i];
                var v0 = this.pos[ f[0] ];
                for ( var j=1; j<f.length-1; ++j ) {
                    var v1 = this.pos[ f[j] ];
                    var v2 = this.pos[ f[j+1] ];
                    var e0 = v1.sub(v0);
                    var e1 = v2.sub(v0);
                    var n  = e0.cross(e1);
                    n = n.unit();
                    this.nrm[ nf[0  ] ].inc(n);
                    this.nrm[ nf[j  ] ].inc(n);
                    this.nrm[ nf[j+1] ].inc(n);
                }
            }
            for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].normalize();
            updateBuffer( this.buffers.normalBuffer, this.mesh.nfac, this.nrm );
    
            // Update the mesh drawer and redraw scene
            meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );
    
            pointDrawer.updatePoint();

            DrawScene();
        }
    
        simTimeStep()
        {
            // remember the position of the selected vertex, if any
            var p = this.holdVert ? this.holdVert.copy() : undefined;
    
            // Update positions and velocities
            var timestep = document.getElementById('timestep').value;
            const dt = timestep / 1000;	// time step in seconds
            const damping = this.damping * this.stiffness * dt;
            SimTimeStep( dt, this.pos, this.vel, this.springs, this.stiffness, damping, this.mass, this.gravity, this.restitution );
            //console.log("PROVA: " + massSpring.mass)
            waterDrawer.setMassSpring(massSpring);
           // console.log("POSIZIONE: " + waterDrawer.massSpring.pos[0].z);
           // console.log("PROVA: " + waterDrawer.massSpring);
            
            // make sure that the selected vertex does not change position
            if ( p ) {
                this.holdVert.set(p);
                this.vel[ this.selVert ].init(0,0,0);
            }
            
            this.updateMesh();
        }
        startSimulation()
        {
            var timestep = document.getElementById('timestep').value;
            if ( ! this.isSimulationRunning() ) this.timer = setInterval( function(){ massSpring.simTimeStep(); }, timestep );
            waterDrawer.isRunning = true;
            startWaterSimulation();
        }
        stopSimulation()
        {
            clearInterval( this.timer );
            this.timer = undefined;
            waterDrawer.isRunning = false;
        }
        isSimulationRunning() { return this.timer !== undefined; }
        restartSimulation() { if ( this.isSimulationRunning() ) { this.stopSimulation(); this.startSimulation(); } }
        toggleSimulation( btn )
        {
            if ( this.isSimulationRunning() ) {
                this.stopSimulation();
                btn.value = "Start Simulation";
            } else {
                this.startSimulation();
                btn.value = "Stop Simulation";
            }
        }
        
        mouseMove()
        {
            var m = MousePos();
            this.selVert = undefined;
            var selPt;
            var minDist = 10;
            for ( var i=0; i<this.pos.length; ++i ) {
                var p = this.pos[i];
                var pv = p.trans(MVP);
                var px = pv.x / pv.w;
                var py = pv.y / pv.w;
                var dx = m.x - px;
                var dy = m.y - py;
                var len2 = dx*dx + dy*dy;
                if ( len2 < 0.001 && len2 < minDist ) {
                    minDist = len2;
                    this.selVert = i;
                    selPt = p;
                }
            }
            if ( pointDrawer.setPoint( selPt ) ) {
                DrawScene();
                canvas.className = selPt ? "sel" : "";
            }

        }
        
        mouseDown()
        {
            if ( this.selVert === undefined ) return false;
            var mInv = MatrixInverse(MVP);
            var p = this.pos[ this.selVert ];
            var pv = p.trans(MVP);
            this.holdVert = this.pos[ this.selVert ];
            
            function mouse4D()
            {
                var m = MousePos();
                return {
                    x: m.x * pv.w,
                    y: m.y * pv.w,
                    z: pv.z,
                    w: pv.w
                };
            }
            
            function invTrans(v)
            {
                return {
                    x: mInv[0]*v.x + mInv[4]*v.y + mInv[ 8]*v.z + mInv[12]*v.w,
                    y: mInv[1]*v.x + mInv[5]*v.y + mInv[ 9]*v.z + mInv[13]*v.w,
                    z: mInv[2]*v.x + mInv[6]*v.y + mInv[10]*v.z + mInv[14]*v.w,
                    w: mInv[3]*v.x + mInv[7]*v.y + mInv[11]*v.z + mInv[15]*v.w
                };
            }
            
            function mouse3D() { 
                var m = invTrans(mouse4D());
                return new Vec3( m.x/m.w, m.y/m.w, m.z/m.w );
            }
            
            var m0 = mouse3D();
            var ms = this;
            
            canvas.onmousemove = function() {
                var m1 = mouse3D();
                var d = m1.sub(m0);
                m0 = { ...m1 };
                p.inc(d);
                ms.updateMesh();
            }
            return true;		
        }
        
        mouseUp()
        {
            this.holdVert = undefined;
        }
    }
    ///////////////////////////////////////////////////////////////////////////////////
    </script>
    
    <script type="text/javascript">
    ///////////////////////////////////////////////////////////////////////////////////
    // Below are the main UI control functions.
    ///////////////////////////////////////////////////////////////////////////////////
    
    var showBox;
    
    window.onload = function() {
        showBox = document.getElementById('show-box');
       // massSpring = new MassSpring();
        InitWebGL();
        lightView = new LightView();
        canvas.zoom = function( s ) {
            transZ *= s/canvas.height + 1;
            UpdateViewMatrices();
            DrawScene();
        }
        canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }
        canvas.onmousedown = function() {
            if ( massSpring.mouseDown() ) {
                canvas.ondblclick = null;
                return;
            }
            canvas.ondblclick = canvas.resetView;
            var cx = event.clientX;
            var cy = event.clientY;
            if ( event.ctrlKey ) {
                canvas.onmousemove = function() {
                    canvas.zoom(5*(event.clientY - cy));
                    cy = event.clientY;
                }
            } else if ( event.altKey ) {
                canvas.onmousemove = function() {
                    let s = 1.5*transZ*(event.clientY - cy);
                    transY -= s/canvas.height;
                    UpdateViewMatrices();
                    DrawScene();
                    cy = event.clientY;
                }
            } else {
                canvas.onmousemove = function() {
                    rotY += (cx - event.clientX)/canvas.width*5;
                    rotX += (cy - event.clientY)/canvas.height*5;
                    cx = event.clientX;
                    cy = event.clientY;
                    UpdateViewMatrices();
                    DrawScene();
                }
            }
        }
        canvas.onmouseup = canvas.onmouseleave = function() {
            massSpring.mouseUp();
            canvas.onmousemove = function() { massSpring.mouseMove(); }
        }
        canvas.onmousemove = function() { massSpring.mouseMove(); }
        canvas.resetView = function() {
            rotX = 0;
            rotY = 0;
            transY = 0;
            transZ = 3;
            UpdateViewMatrices();
            DrawScene();
        }
        
        massSpring = new MassSpring();



        //waterDrawer.setMassSpring(massSpring);
        //console.log("NODES: " + massSpring.nodes); 
        //console.log("WATER: " + waterDrawer.massSpring);
        
        SetGravity  ( document.getElementById('gravity') );
        SetMass     ( document.getElementById('mass') );
        SetStiffness( document.getElementById('stiffness') );
        SetShininess( document.getElementById('shininess-exp') );
    
        DrawScene();
    };
    function WindowResize()
    {
        UpdateCanvasSize();
        DrawScene();
    }
    
    function MousePos()
    {
        return {
            x:  ( event.clientX / canvas.clientWidth  ) * 2 - 1,
            y: -( event.clientY / canvas.clientHeight ) * 2 + 1
        };
    }
    
    function ShowTexture( param )
    {
        meshDrawer.showTexture( param.checked );
        DrawScene();
    }
    
    function LoadObj( param )
    {
        if ( param.files && param.files[0] ) {
            var reader = new FileReader();
            reader.onload = function(e) {
                massSpring.setMesh( e.target.result );
            }
            reader.readAsText( param.files[0] );
        }
    }
    
    function LoadTexture( param )
    {
        if ( param.files && param.files[0] ) {
            var reader = new FileReader();
            reader.onload = function(e) {
                var img = document.getElementById('texture-img');
                img.onload = function() {
                    meshDrawer.setTexture( img );
                    DrawScene();
                }
                img.src = e.target.result;
            };
            reader.readAsDataURL( param.files[0] );
        }
    }
    
    function SetTimeStepSize( param )
    {
        var s = param.value;
        document.getElementById('timestep-value').innerText = s + " ms";
        waterDrawer.TIME_STEP = s*0.001;
    }
    
    function SetGravity( param )
    {
        var v = param.value;
        var s = v / 20;
        document.getElementById('gravity-value').innerText = s.toFixed( 2 );
        massSpring.gravity.y = -s;
        waterDrawer.GRAVITY[1] = -s;
    }
    
    function SetMass( param )
    {
        var v = param.value;
        var s = v / 200;
        document.getElementById('mass-value').innerText = s.toFixed( 3 );
        massSpring.mass = s;
        waterDrawer.MASS = s * 0.0064; //Old value 6390
    }
    
    function SetStiffness( param )
    {
        var v = param.value;
        var s = v / 20;
        document.getElementById('stiffness-value').innerText = s.toFixed( 2 );
        massSpring.stiffness = s;
    }
    
    function SetDamping( param )
    {
        var v = param.value;
        var s = v / 20;
        document.getElementById('damping-value').innerText = s.toFixed( 2 );
        massSpring.damping = s;
    }
    
    function SetShininess( param )
    {
        var exp = param.value;
        var s = Math.pow(10,exp/25);
        document.getElementById('shininess-value').innerText = s.toFixed( s < 10 ? 2 : 0 );
        meshDrawer.setShininess(s);
        DrawScene();
    }

    var particles = 1000; // accuratezza dello slider

    function SetParticle(param) {
        var p = param.value;
        particles = Math.round(p / 2);  // Arrotonda a intero

        document.getElementById('water-particle-value').innerText = particles;

        // Rigenera le particelle con il nuovo valore di particles
        GenerateParticles();
    }

    function GenerateParticles() {
        waterDrawer.clearParticles(); // Pulisce le particelle esistenti (dovrai implementare questo metodo)

        for (let i = 0; i < particles; i++) {
            let x = -1 + Math.random() * 2;   // x tra -1 e 1
            let y = -1.5 + Math.random();     // y tra -1.5 e -0.5
            let z = -1 + Math.random() * 2;   // z tra -1 e 1
            
            // Filtra le particelle che escono dai limiti del cubo
            if (y >= -1 && y <= 1) { 
                waterDrawer.addPoint({x: x, y: y, z: z});
            }
        }
    }

    
    ///////////////////////////////////////////////////////////////////////////////////
    </script>
    
    <script id="box.obj" type="text/obj">
    v  -1  1 -1
    v  -1 -1 -1
    v   1 -1 -1
    v   1  1 -1
    v   1 -1  1
    v  -1 -1  1
    v  -1  1  1
    v   1  1  1
    vn  0  0  1
    vn  0  0  1
    vn  0  0  1
    vn  0  0  1
    vn  0  0 -1
    vn  0  0 -1
    vn  0  0 -1
    vn  0  0 -1
    vn  0  1  0
    vn  0  1  0
    vn  0  1  0
    vn  0  1  0
    vn -1  0  0
    vn -1  0  0
    vn -1  0  0
    vn -1  0  0
    vn  0 -1  0
    vn  0 -1  0
    vn  0 -1  0
    vn  0 -1  0
    vn  1  0  0
    vn  1  0  0
    vn  1  0  0
    vn  1  0  0
    vt 0 0
    vt 0 1
    vt 1 1
    vt 1 0
    f 1/1/1  4/4/4  3/3/3  2/2/2  
    f 5/1/5  8/4/8  7/3/7  6/2/6  
    f 3/1/9  5/4/12 6/3/11 2/2/10 
    f 4/1/13 8/4/16 5/3/15 3/2/14 
    f 1/1/17 7/4/20 8/3/19 4/2/18 
    f 2/1/21 6/4/24 7/3/23 1/2/22 
    </script>
    
    <style>
    html {
        color: white;
        background-color: black;
        font-family: Arial;
        overflow: hidden;
    }
    body {
        padding: 0;
        margin: 0;
    }
    input[type=checkbox], label {
        cursor: hand;
    }
    input[type=range] {
        width: 100%;
    }
    input[type=button] {
        width: 100%;
        min-width: 9em;
    }
    #canvas {
        display: block;
        position: absolute;
        top:  0;
        left: 0;
        width:  100%;
        height: 100%;
    }
    #canvas-div {
        position: relative;
    }
    .sel {
        cursor: hand;
    }
    #controls-div {
        vertical-align: top;
        background-color: #333;
        overflow: auto;
    }
    #controls {
        padding: 1em;
    }
    .control-group {
        position: relative;
        max-width: 12em;
    }
    .control {
        padding: 0.2em;
    }
    .control-x {
        display: none;
    }
    #lightcontrol {
        width:  12em;
        height: 12em;
        background-color: black;
        outline: 1px solid white;
        outline-offset: -1px;
    }
    #lightcontrol-label {
        position: absolute;
        top: 0.2em;
        left: 0.2em;
        pointer-events: none;
    }
    #shininess-label {
        float: left;
    }
    .value {
        float: right;
        text-align: right;
        width: 4em;
    }
    @media (orientation: landscape) {
        #canvas-div {
            display: inline-block;
            width:  calc(100% - 14em);
            height: 100%;
        }
        #controls-div {
            display: inline-block;
            width:   14em;
            height: 100%;
        }
        .control-group {
            overflow: hidden;
        }
        .control-group ~ .control-group {
            margin-top: 1em;
        }
        #texture-img {
            width: 100%;
            height: auto;
        }
    }
    @media (orientation: portrait) {
        #canvas-div {
            width:  100%;
            height: calc(100% - 20em);
        }
        #controls-div {
            width:  100%;
            height: 20em;
        }
        .control-group {
            display: inline-block;
            vertical-align: top;
        }
        .control-group ~ .control-group {
            margin-left: 2em;
        }
        #texture-img {
            width: auto;
            height: 5em;
        }
    }
    </style>
    
    </head>
    <body onresize="WindowResize()">
    <div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
    <div id="controls">
    <div class="control-group"><canvas id="lightcontrol"></canvas><div id="lightcontrol-label">Light Direction</div></div>
    <div class="control-group">
    <div class="control"><input type="button" value="Start Simulation" onclick="massSpring.toggleSimulation(this)"></div>
    <div class="control"><input type="button" value="Reset" onclick="massSpring.reset();DrawScene()"></div>
    <div class="control"><span id="timestep-label">Time Step Size:</span><span class="value" id="timestep-value">20 ms</span><input id="timestep" type="range" min="1" max="100" value="20" oninput="SetTimeStepSize(this)" onchange="massSpring.restartSimulation()" ondblclick="this.value=20;this.oninput();this.onchange()"/></div>
    <div class="control"><span id="gravity-label">Gravity:</span><span class="value" id="gravity-value">1</span><input id="gravity" type="range" min="0" max="100" value="20" oninput="SetGravity(this)" ondblclick="this.value=20;this.oninput()"/></div>
    <div class="control"><span id="mass-label">Mass:</span><span class="value" id="mass-value">1</span><input id="mass" type="range" min="1" max="100" value="20" oninput="SetMass(this)" ondblclick="this.value=20;this.oninput()"/></div>
    <div class="control"><span id="stiffness-label">Stiffness:</span><span class="value" id="stiffness-value">1</span><input id="stiffness" type="range" min="0" max="100" value="20" oninput="SetStiffness(this)" ondblclick="this.value=20;this.oninput()"/></div>
    <div class="control"><span id="damping-label">Damping:</span><span class="value" id="damping-value">1.00</span><input id="damping" type="range" min="0" max="100" value="20" oninput="SetDamping(this)" ondblclick="this.value=20;this.oninput()"/></div>
    </div>
    <div class="control-group">
    <div class="control"><input id="show-box" name="show-box" type="checkbox" onchange="DrawScene()" checked /><label for="show-box"> Show Box</label></div>
    <div class="control"><input id="show-texture" name="show-texture" type="checkbox" onchange="ShowTexture(this)" checked /><label for="show-texture"> Show Texture</label></div>
    <div class="control"><span id="shininess-label">Shininess:</span><span class="value" id="shininess-value">1</span><input id="shininess-exp" type="range" min="0" max="100" value="50" oninput="SetShininess(this)" ondblclick="this.value=50;this.oninput()"/></div>
    <div class="control">OBJ model:<br/><input id="obj" type="file" onchange="LoadObj(this)" accept=".obj"/></div>
    <div class="control">Texture image:<br/><input id="texture" type="file" onchange="LoadTexture(this)" accept="image/*"/></div>
    <div class="control"><img id="texture-img" /></div>
    <div class="control"><span id="water-particle-label">Water Particle:</span><span class="value" id="water-particle-value">2500</span><input id="waterParticle" type="range" min="0" max="40000" value="1000" oninput="SetParticle(this)" ondblclick="this.value=10000;this.oninput()"/></div>
    </div>
    </div>
    </div>
    </body>
    </html>